# Problem Statement:
Need a long term storage solution to allow a user to persist data across sessions. The data to be entered and stored need to be sufficient to calculate return on investment for individual transactions as an annualized rate.

# Background Research:
The formula for calculating a single transaction's performance is:

ROI = (Current Value of Investment - Cost of Investment) / Cost of Investment

https://www.investopedia.com/terms/r/returnoninvestment.asp

ROI is interesting, but is biased by length of time and inflows and outflows of cash. In order to compare performance over time across portfolios, we need to adjust for time.

TWR = [(1 + HP1) * (1 + HP2) * ... * (1 + HPN)] - 1  
where:  
TWR = Time weighted return  
n = Number of sub-periods  
HP = (End Value - Initial Value + Cash Flow) / (Initial Value + Cash Flow)  
HPN = Return for sub-period n  

https://www.investopedia.com/terms/t/time-weightedror.asp

## SQLite:
SQLite is simple and free to use. It allows us to use familiar SQL syntax for database access.
https://www.sqlite.org/index.html

### Datatypes:
https://www.sqlite.org/datatype3.html  
NULL, INTEGER, REAL, TEXT, BLOB  
DATETIMEs can be stored as TEXT, INTEGER, or REAL. Advantages / disadvantages here: https://stackoverflow.com/questions/17227110/how-do-datetime-values-work-in-sqlite

### Conventions:
https://www.xaprb.com/blog/2008/10/26/the-power-of-a-good-sql-naming-convention/
https://stackoverflow.com/questions/7662/database-table-and-column-naming-conventions  
Top takeaways:  
Pascal case for table and column names. ID columns should be named by the table + ID. Column names with the same data as in another table should be named the same.

Project conventions for SQL are at ../Conventions/SQLConventions.md

# High Level Design:
We will store transaction level data that can be used to build the time weighted periods as needed.

# Considered, But Not Done:
* Storing period performance data. We could, but that immediately introduces a second source of truth to keep in sync. The raw data gives more flexibility to calculate other data of interest. 
* Developing a generic menu options framework. It's not the point right now. We can just hard-code menu code for now.
* Support deleting an existing database. For starters, we just want to create the database, and we will assume that one does not already exist.
* Make a generic framework for building the needed SQL statements. For now, we will hard code create statements, generated by the SQLite DB application with the given parameters described in the detailed design.

# Detailed Design:
There will be a new database to hold application data. At this point, the plan is to use a single database, with multiple tables as needed. There will be a new Transactions table, along with an Actions and Classes table.

## Transactions
Contains details of individual transactions. A transaction is a single exchange of cash for a security, or a cash inflow / outflow from the portfolio.

| Name | Type | NonNull | PrimaryKey | AutoIncrement | Unique | Default | Check | Foreign Key |
| ---- | ---- | ------- | ---------- | ------------- | ------ | ------- | ----- | ----------- |
| TransactionID | INTEGER || YES |
| Date | TEXT | YES |
| ActionID | INTEGER | YES |||||| "Actions"("ActionID") |
| ClassID | INTEGER | YES |||||| "Classes"("ClassID") |
| Ticker | TEXT |
| Amount | NUMERIC | YES |

## Actions
Actions describe the transactions interaction with the cash account. The actions may be buy, sell, deposit or withdrawal.

| Name | Type | NonNull | PrimaryKey | AutoIncrement | Unique | Default | Check | Foreign Key |
| ---- | ---- | ------- | ---------- | ------------- | ------ | ------- | ----- | ----------- |
| ActionID | INTEGER || YES |
| Name | TEXT | YES |

## Classes
Classes describe additional type information about a transaction. It might be stock, interest, bond, or transfer.

| Name | Type | NonNull | PrimaryKey | AutoIncrement | Unique | Default | Check | Foreign Key |
| ---- | ---- | ------- | ---------- | ------------- | ------ | ------- | ----- | ----------- |
| ClassID | INTEGER || YES |
| Name | TEXT | YES |||||||

# Technical Design:
## Database
We will use SQLite as the backend. For a driver, we will use the command line application. We will hard code in some basic menu looking option, and will allow selecting by number. In this case, the only option will be install. We will create a new database within the application working directory, with the three defined tables.

CREATE TABLE "Actions" (
	"ActionID"	INTEGER NOT NULL UNIQUE,
	"Name"	TEXT NOT NULL,
	PRIMARY KEY("ActionID")
);

CREATE TABLE "Classes" (
	"ClassID"	INTEGER NOT NULL,
	"Name"	TEXT NOT NULL,
	PRIMARY KEY("ClassID")
);

CREATE TABLE "Transactions" (
	"TransactionID"	INTEGER,
	"Date"	TEXT NOT NULL,
	"ActionID"	INTEGER NOT NULL,
	"ClassID"	INTEGER NOT NULL,
	"Ticker"	TEXT,
	"Amount"	NUMERIC NOT NULL,
	FOREIGN KEY("ActionID") REFERENCES "Actions"("ActionID"),
	PRIMARY KEY("TransactionID")
);

## Project Organization
We will use separate projects for each platform, in order to separate dependencies. We will need a new project for SQLite specific code, one for the command line interface, and one for platform neutral code.

CommandLine.csproj
Core.csproj
SQLiteDatabase.csproj

For this design, the SQLiteDatabase will get code to create the database and tables. The core project will have the generic code for calling into the install code in the SQLiteDatabase project, and the command line will have the menu structure to call into the core code.

Additionally, there will be a test project to go with each main project. We will keep a separate directory for the test projects.
